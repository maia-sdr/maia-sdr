# ! [doc = "Peripheral access API for MAIA SDR microcontrollers (generated using svd2rust v0.29.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.29.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
# ! [deny (dead_code)]
# ! [deny (improper_ctypes)]
# ! [deny (missing_docs)]
# ! [deny (no_mangle_generic_items)]
# ! [deny (non_shorthand_field_patterns)]
# ! [deny (overflowing_literals)]
# ! [deny (path_statements)]
# ! [deny (patterns_in_fns_without_body)]
# ! [deny (private_in_public)]
# ! [deny (unconditional_recursion)]
# ! [deny (unused_allocation)]
# ! [deny (unused_comparisons)]
# ! [deny (unused_parens)]
# ! [deny (while_true)]
# ! [allow (non_camel_case_types)]
# ! [allow (non_snake_case)]
# ! [no_std]
use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [allow (unused_imports)]
use generic :: * ; # [doc = r"Common register and bit access and modify traits"]
pub mod generic { use core :: marker ; # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
pub trait RawReg : Copy + Default + From < bool > + core :: ops :: BitOr < Output = Self > + core :: ops :: BitAnd < Output = Self > + core :: ops :: BitOrAssign + core :: ops :: BitAndAssign + core :: ops :: Not < Output = Self > + core :: ops :: Shl < u8 , Output = Self > { # [doc = " Mask for bits of width `WI`"]
fn mask < const WI : u8 > () -> Self ; # [doc = " Mask for bits of width 1"]
fn one () -> Self ; } macro_rules ! raw_reg { ($ U : ty , $ size : literal , $ mask : ident) => { impl RawReg for $ U { # [inline (always)]
fn mask < const WI : u8 > () -> Self { $ mask ::< WI > () } # [inline (always)]
fn one () -> Self { 1 } } const fn $ mask < const WI : u8 > () -> $ U { <$ U >:: MAX >> ($ size - WI) } impl FieldSpec for $ U { type Ux = $ U ; } } ; } raw_reg ! (u8 , 8 , mask_u8) ; raw_reg ! (u16 , 16 , mask_u16) ; raw_reg ! (u32 , 32 , mask_u32) ; raw_reg ! (u64 , 64 , mask_u64) ; # [doc = " Raw register type"]
pub trait RegisterSpec { # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
type Ux : RawReg ; } # [doc = " Raw field type"]
pub trait FieldSpec : Sized { # [doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
type Ux : Copy + PartialEq + From < Self > ; } # [doc = " Trait implemented by readable registers to enable the `read` method."]
# [doc = ""]
# [doc = " Registers marked with `Writable` can be also be `modify`'ed."]
pub trait Readable : RegisterSpec { # [doc = " Result from a call to `read` and argument to `modify`."]
type Reader : From < R < Self > > + core :: ops :: Deref < Target = R < Self > > ; } # [doc = " Trait implemented by writeable registers."]
# [doc = ""]
# [doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
# [doc = ""]
# [doc = " Registers marked with `Readable` can be also be `modify`'ed."]
pub trait Writable : RegisterSpec { # [doc = " Writer type argument to `write`, et al."]
type Writer : From < W < Self > > + core :: ops :: DerefMut < Target = W < Self > > ; # [doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; # [doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; } # [doc = " Reset value of the register."]
# [doc = ""]
# [doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
# [doc = " register by using the `reset` method."]
pub trait Resettable : RegisterSpec { # [doc = " Reset value of the register."]
const RESET_VALUE : Self :: Ux ; # [doc = " Reset value of the register."]
# [inline (always)]
fn reset_value () -> Self :: Ux { Self :: RESET_VALUE } } # [doc = " This structure provides volatile access to registers."]
# [repr (transparent)]
pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > { # [doc = " Returns the underlying memory address of register."]
# [doc = ""]
# [doc = " ```ignore"]
# [doc = " let reg_ptr = periph.reg.as_ptr();"]
# [doc = " ```"]
# [inline (always)]
pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > { # [doc = " Reads the contents of a `Readable` register."]
# [doc = ""]
# [doc = " You can read the raw contents of a register by using `bits`:"]
# [doc = " ```ignore"]
# [doc = " let bits = periph.reg.read().bits();"]
# [doc = " ```"]
# [doc = " or get the content of a particular field of a register:"]
# [doc = " ```ignore"]
# [doc = " let reader = periph.reg.read();"]
# [doc = " let bits = reader.field1().bits();"]
# [doc = " let flag = reader.field2().bit_is_set();"]
# [doc = " ```"]
# [inline (always)]
pub fn read (& self) -> REG :: Reader { REG :: Reader :: from (R { bits : self . register . get () , _reg : marker :: PhantomData , }) } } impl < REG : Resettable + Writable > Reg < REG > { # [doc = " Writes the reset value to `Writable` register."]
# [doc = ""]
# [doc = " Resets the register to its initial state."]
# [inline (always)]
pub fn reset (& self) { self . register . set (REG :: RESET_VALUE) } # [doc = " Writes bits to a `Writable` register."]
# [doc = ""]
# [doc = " You can write raw bits into a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
# [doc = " ```"]
# [doc = " or write only the fields you need:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " In the latter case, other fields will be set to their reset value."]
# [inline (always)]
pub fn write < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > , { self . register . set (f (& mut REG :: Writer :: from (W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , })) . bits ,) ; } } impl < REG : Writable > Reg < REG > { # [doc = " Writes 0 to a `Writable` register."]
# [doc = ""]
# [doc = " Similar to `write`, but unused bits will contain 0."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Unsafe to use with registers which don't allow to write 0."]
# [inline (always)]
pub unsafe fn write_with_zero < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > , { self . register . set (f (& mut REG :: Writer :: from (W { bits : REG :: Ux :: default () , _reg : marker :: PhantomData , })) . bits ,) ; } } impl < REG : Readable + Writable > Reg < REG > { # [doc = " Modifies the contents of the register by reading and then writing it."]
# [doc = ""]
# [doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
# [doc = "    r.bits() | 3"]
# [doc = " ) });"]
# [doc = " ```"]
# [doc = " or"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " Other fields will have the value they had before the call to `modify`."]
# [inline (always)]
pub fn modify < F > (& self , f : F) where for < 'w > F : FnOnce (& REG :: Reader , & 'w mut REG :: Writer) -> & 'w mut W < REG > , { let bits = self . register . get () ; self . register . set (f (& REG :: Reader :: from (R { bits , _reg : marker :: PhantomData , }) , & mut REG :: Writer :: from (W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , }) ,) . bits ,) ; } } # [doc = " Register reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
# [doc = " method."]
pub struct R < REG : RegisterSpec + ? Sized > { pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > R < REG > { # [doc = " Reads raw bits from register."]
# [inline (always)]
pub fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy , REG :: Ux : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& REG :: Ux :: from (* other)) } } # [doc = " Register writer."]
# [doc = ""]
# [doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
pub struct W < REG : RegisterSpec + ? Sized > { # [doc = "Writable bits"]
pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > W < REG > { # [doc = " Writes raw bits to the register."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Read datasheet or reference manual to find what values are allowed to pass."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } # [doc (hidden)]
pub struct FieldReaderRaw < FI = u8 > where FI : FieldSpec { pub (crate) bits : FI :: Ux , _reg : marker :: PhantomData < FI > , } impl < FI : FieldSpec > FieldReaderRaw < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : FI :: Ux) -> Self { Self { bits , _reg : marker :: PhantomData , } } } # [doc (hidden)]
pub struct BitReaderRaw < FI = bool > { pub (crate) bits : bool , _reg : marker :: PhantomData < FI > , } impl < FI > BitReaderRaw < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : bool) -> Self { Self { bits , _reg : marker :: PhantomData , } } } # [doc = " Field reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of fields."]
pub type FieldReader < FI = u8 > = FieldReaderRaw < FI > ; # [doc = " Bit-wise field reader"]
pub type BitReader < FI = bool > = BitReaderRaw < FI > ; impl < FI : FieldSpec > FieldReader < FI > { # [doc = " Reads raw bits from field."]
# [inline (always)]
pub fn bits (& self) -> FI :: Ux { self . bits } } impl < FI > PartialEq < FI > for FieldReader < FI > where FI : FieldSpec + Copy , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& FI :: Ux :: from (* other)) } } impl < FI > PartialEq < FI > for BitReader < FI > where FI : Copy , bool : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& bool :: from (* other)) } } impl < FI > BitReader < FI > { # [doc = " Value of the field as raw bits."]
# [inline (always)]
pub fn bit (& self) -> bool { self . bits } # [doc = " Returns `true` if the bit is clear (0)."]
# [inline (always)]
pub fn bit_is_clear (& self) -> bool { ! self . bit () } # [doc = " Returns `true` if the bit is set (1)."]
# [inline (always)]
pub fn bit_is_set (& self) -> bool { self . bit () } } # [doc (hidden)]
pub struct Safe ; # [doc (hidden)]
pub struct Unsafe ; # [doc (hidden)]
pub struct FieldWriterRaw < 'a , REG , const WI : u8 , const O : u8 , FI = u8 , Safety = Unsafe > where REG : Writable + RegisterSpec , FI : FieldSpec , { pub (crate) w : & 'a mut REG :: Writer , _field : marker :: PhantomData < (FI , Safety) > , } impl < 'a , REG , const WI : u8 , const O : u8 , FI , Safety > FieldWriterRaw < 'a , REG , WI , O , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut REG :: Writer) -> Self { Self { w , _field : marker :: PhantomData , } } } # [doc (hidden)]
pub struct BitWriterRaw < 'a , REG , const O : u8 , FI = bool , M = BitM > where REG : Writable + RegisterSpec , bool : From < FI > , { pub (crate) w : & 'a mut REG :: Writer , _field : marker :: PhantomData < (FI , M) > , } impl < 'a , REG , const O : u8 , FI , M > BitWriterRaw < 'a , REG , O , FI , M > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut REG :: Writer) -> Self { Self { w , _field : marker :: PhantomData , } } } # [doc = " Write field Proxy with unsafe `bits`"]
pub type FieldWriter < 'a , REG , const WI : u8 , const O : u8 , FI = u8 > = FieldWriterRaw < 'a , REG , WI , O , FI , Unsafe > ; # [doc = " Write field Proxy with safe `bits`"]
pub type FieldWriterSafe < 'a , REG , const WI : u8 , const O : u8 , FI = u8 > = FieldWriterRaw < 'a , REG , WI , O , FI , Safe > ; impl < 'a , REG , const WI : u8 , const OF : u8 , FI > FieldWriter < 'a , REG , WI , OF , FI > where REG : Writable + RegisterSpec , FI : FieldSpec , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; } impl < 'a , REG , const WI : u8 , const OF : u8 , FI > FieldWriterSafe < 'a , REG , WI , OF , FI > where REG : Writable + RegisterSpec , FI : FieldSpec , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; } macro_rules ! bit_proxy { ($ writer : ident , $ mwv : ident) => { # [doc (hidden)]
pub struct $ mwv ; # [doc = " Bit-wise write field proxy"]
pub type $ writer <'a , REG , const O : u8 , FI = bool > = BitWriterRaw <'a , REG , O , FI , $ mwv >; impl <'a , REG , const OF : u8 , FI > $ writer <'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI >, { # [doc = " Field width"]
pub const WIDTH : u8 = 1 ; } } ; } macro_rules ! impl_bit_proxy { ($ writer : ident) => { impl <'a , REG , const OF : u8 , FI > $ writer <'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI >, { # [doc = " Writes bit to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> &'a mut REG :: Writer { self . w . bits &= ! (REG :: Ux :: one () << OF) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: one ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> &'a mut REG :: Writer { self . bit (bool :: from (variant)) } } } ; } bit_proxy ! (BitWriter , BitM) ; bit_proxy ! (BitWriter1S , Bit1S) ; bit_proxy ! (BitWriter0C , Bit0C) ; bit_proxy ! (BitWriter1C , Bit1C) ; bit_proxy ! (BitWriter0S , Bit0S) ; bit_proxy ! (BitWriter1T , Bit1T) ; bit_proxy ! (BitWriter0T , Bit0T) ; impl < 'a , REG , const WI : u8 , const OF : u8 , FI > FieldWriter < 'a , REG , WI , OF , FI > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , { # [doc = " Writes raw bits to the field"]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (self , value : FI :: Ux) -> & 'a mut REG :: Writer { self . w . bits &= ! (REG :: Ux :: mask :: < WI > () << OF) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: mask :: < WI > ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut REG :: Writer { unsafe { self . bits (FI :: Ux :: from (variant)) } } } impl < 'a , REG , const WI : u8 , const OF : u8 , FI > FieldWriterSafe < 'a , REG , WI , OF , FI > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , { # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn bits (self , value : FI :: Ux) -> & 'a mut REG :: Writer { self . w . bits &= ! (REG :: Ux :: mask :: < WI > () << OF) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: mask :: < WI > ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut REG :: Writer { self . bits (FI :: Ux :: from (variant)) } } impl_bit_proxy ! (BitWriter) ; impl_bit_proxy ! (BitWriter1S) ; impl_bit_proxy ! (BitWriter0C) ; impl_bit_proxy ! (BitWriter1C) ; impl_bit_proxy ! (BitWriter0S) ; impl_bit_proxy ! (BitWriter1T) ; impl_bit_proxy ! (BitWriter0T) ; impl < 'a , REG , const OF : u8 , FI > BitWriter < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= REG :: Ux :: one () << OF ; self . w } # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (REG :: Ux :: one () << OF) ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter1S < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= REG :: Ux :: one () << OF ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter0C < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (REG :: Ux :: one () << OF) ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter1C < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Clears the field bit by passing one"]
# [inline (always)]
pub fn clear_bit_by_one (self) -> & 'a mut REG :: Writer { self . w . bits |= REG :: Ux :: one () << OF ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter0S < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Sets the field bit by passing zero"]
# [inline (always)]
pub fn set_bit_by_zero (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (REG :: Ux :: one () << OF) ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter1T < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Toggle the field bit by passing one"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= REG :: Ux :: one () << OF ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter0T < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Toggle the field bit by passing zero"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (REG :: Ux :: one () << OF) ; self . w } } } # [doc = "Maia SDR IP core"]
pub struct MAIA_SDR { _marker : PhantomData < * const () > } unsafe impl Send for MAIA_SDR { } impl MAIA_SDR { # [doc = r"Pointer to the register block"]
pub const PTR : * const maia_sdr :: RegisterBlock = 0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const maia_sdr :: RegisterBlock { Self :: PTR } } impl Deref for MAIA_SDR { type Target = maia_sdr :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for MAIA_SDR { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("MAIA_SDR") . finish () } } # [doc = "Maia SDR IP core"]
pub mod maia_sdr { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - product_id"]
pub product_id : PRODUCT_ID , # [doc = "0x04 - version"]
pub version : VERSION , # [doc = "0x08 - control"]
pub control : CONTROL , # [doc = "0x0c - interrupts"]
pub interrupts : INTERRUPTS , # [doc = "0x10 - recorder_control"]
pub recorder_control : RECORDER_CONTROL , # [doc = "0x14 - recorder_next_address"]
pub recorder_next_address : RECORDER_NEXT_ADDRESS , _reserved6 : [u8 ; 0x08]
, # [doc = "0x20 - spectrometer"]
pub spectrometer : SPECTROMETER , } # [doc = "product_id (r) register accessor: an alias for `Reg<PRODUCT_ID_SPEC>`"]
pub type PRODUCT_ID = crate :: Reg < product_id :: PRODUCT_ID_SPEC > ; # [doc = "product_id"]
pub mod product_id { # [doc = "Register `product_id` reader"]
pub struct R (crate :: R < PRODUCT_ID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRODUCT_ID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRODUCT_ID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRODUCT_ID_SPEC >) -> Self { R (reader) } } # [doc = "Field `product_id` reader - product_id"]
pub type PRODUCT_ID_R = crate :: FieldReader < u32 > ; impl R { # [doc = "Bits 0:31 - product_id"]
# [inline (always)]
pub fn product_id (& self) -> PRODUCT_ID_R { PRODUCT_ID_R :: new (self . bits) } } # [doc = "product_id\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [product_id](index.html) module"]
pub struct PRODUCT_ID_SPEC ; impl crate :: RegisterSpec for PRODUCT_ID_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [product_id::R](R) reader structure"]
impl crate :: Readable for PRODUCT_ID_SPEC { type Reader = R ; } } # [doc = "version (r) register accessor: an alias for `Reg<VERSION_SPEC>`"]
pub type VERSION = crate :: Reg < version :: VERSION_SPEC > ; # [doc = "version"]
pub mod version { # [doc = "Register `version` reader"]
pub struct R (crate :: R < VERSION_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < VERSION_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < VERSION_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < VERSION_SPEC >) -> Self { R (reader) } } # [doc = "Field `bugfix` reader - bugfix"]
pub type BUGFIX_R = crate :: FieldReader ; # [doc = "Field `minor` reader - minor"]
pub type MINOR_R = crate :: FieldReader ; # [doc = "Field `major` reader - major"]
pub type MAJOR_R = crate :: FieldReader ; # [doc = "Field `platform` reader - platform"]
pub type PLATFORM_R = crate :: FieldReader ; impl R { # [doc = "Bits 0:7 - bugfix"]
# [inline (always)]
pub fn bugfix (& self) -> BUGFIX_R { BUGFIX_R :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - minor"]
# [inline (always)]
pub fn minor (& self) -> MINOR_R { MINOR_R :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:23 - major"]
# [inline (always)]
pub fn major (& self) -> MAJOR_R { MAJOR_R :: new (((self . bits >> 16) & 0xff) as u8) } # [doc = "Bits 24:31 - platform"]
# [inline (always)]
pub fn platform (& self) -> PLATFORM_R { PLATFORM_R :: new (((self . bits >> 24) & 0xff) as u8) } } # [doc = "version\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [version](index.html) module"]
pub struct VERSION_SPEC ; impl crate :: RegisterSpec for VERSION_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [version::R](R) reader structure"]
impl crate :: Readable for VERSION_SPEC { type Reader = R ; } } # [doc = "control (rw) register accessor: an alias for `Reg<CONTROL_SPEC>`"]
pub type CONTROL = crate :: Reg < control :: CONTROL_SPEC > ; # [doc = "control"]
pub mod control { # [doc = "Register `control` reader"]
pub struct R (crate :: R < CONTROL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CONTROL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CONTROL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CONTROL_SPEC >) -> Self { R (reader) } } # [doc = "Register `control` writer"]
pub struct W (crate :: W < CONTROL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CONTROL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CONTROL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CONTROL_SPEC >) -> Self { W (writer) } } # [doc = "Field `sdr_reset` reader - sdr_reset"]
pub type SDR_RESET_R = crate :: BitReader ; # [doc = "Field `sdr_reset` writer - sdr_reset"]
pub type SDR_RESET_W < 'a , const O : u8 > = crate :: BitWriter < 'a , CONTROL_SPEC , O > ; impl R { # [doc = "Bit 0 - sdr_reset"]
# [inline (always)]
pub fn sdr_reset (& self) -> SDR_RESET_R { SDR_RESET_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - sdr_reset"]
# [inline (always)]
# [must_use]
pub fn sdr_reset (& mut self) -> SDR_RESET_W < 0 > { SDR_RESET_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [control](index.html) module"]
pub struct CONTROL_SPEC ; impl crate :: RegisterSpec for CONTROL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [control::R](R) reader structure"]
impl crate :: Readable for CONTROL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [control::W](W) writer structure"]
impl crate :: Writable for CONTROL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } } # [doc = "interrupts (r) register accessor: an alias for `Reg<INTERRUPTS_SPEC>`"]
pub type INTERRUPTS = crate :: Reg < interrupts :: INTERRUPTS_SPEC > ; # [doc = "interrupts"]
pub mod interrupts { # [doc = "Register `interrupts` reader"]
pub struct R (crate :: R < INTERRUPTS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTERRUPTS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTERRUPTS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTERRUPTS_SPEC >) -> Self { R (reader) } } # [doc = "Field `spectrometer` reader - spectrometer"]
pub type SPECTROMETER_R = crate :: BitReader ; # [doc = "Field `recorder` reader - recorder"]
pub type RECORDER_R = crate :: BitReader ; impl R { # [doc = "Bit 0 - spectrometer"]
# [inline (always)]
pub fn spectrometer (& self) -> SPECTROMETER_R { SPECTROMETER_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - recorder"]
# [inline (always)]
pub fn recorder (& self) -> RECORDER_R { RECORDER_R :: new (((self . bits >> 1) & 1) != 0) } } # [doc = "interrupts\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [interrupts](index.html) module"]
pub struct INTERRUPTS_SPEC ; impl crate :: RegisterSpec for INTERRUPTS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [interrupts::R](R) reader structure"]
impl crate :: Readable for INTERRUPTS_SPEC { type Reader = R ; } } # [doc = "recorder_control (rw) register accessor: an alias for `Reg<RECORDER_CONTROL_SPEC>`"]
pub type RECORDER_CONTROL = crate :: Reg < recorder_control :: RECORDER_CONTROL_SPEC > ; # [doc = "recorder_control"]
pub mod recorder_control { # [doc = "Register `recorder_control` reader"]
pub struct R (crate :: R < RECORDER_CONTROL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RECORDER_CONTROL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RECORDER_CONTROL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RECORDER_CONTROL_SPEC >) -> Self { R (reader) } } # [doc = "Register `recorder_control` writer"]
pub struct W (crate :: W < RECORDER_CONTROL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RECORDER_CONTROL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RECORDER_CONTROL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RECORDER_CONTROL_SPEC >) -> Self { W (writer) } } # [doc = "Field `start` writer - start"]
pub type START_W < 'a , const O : u8 > = crate :: BitWriter < 'a , RECORDER_CONTROL_SPEC , O > ; # [doc = "Field `stop` writer - stop"]
pub type STOP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , RECORDER_CONTROL_SPEC , O > ; # [doc = "Field `mode_8bit` reader - mode_8bit"]
pub type MODE_8BIT_R = crate :: BitReader ; # [doc = "Field `mode_8bit` writer - mode_8bit"]
pub type MODE_8BIT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , RECORDER_CONTROL_SPEC , O > ; # [doc = "Field `dropped_samples` reader - dropped_samples"]
pub type DROPPED_SAMPLES_R = crate :: BitReader ; impl R { # [doc = "Bit 2 - mode_8bit"]
# [inline (always)]
pub fn mode_8bit (& self) -> MODE_8BIT_R { MODE_8BIT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - dropped_samples"]
# [inline (always)]
pub fn dropped_samples (& self) -> DROPPED_SAMPLES_R { DROPPED_SAMPLES_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - start"]
# [inline (always)]
# [must_use]
pub fn start (& mut self) -> START_W < 0 > { START_W :: new (self) } # [doc = "Bit 1 - stop"]
# [inline (always)]
# [must_use]
pub fn stop (& mut self) -> STOP_W < 1 > { STOP_W :: new (self) } # [doc = "Bit 2 - mode_8bit"]
# [inline (always)]
# [must_use]
pub fn mode_8bit (& mut self) -> MODE_8BIT_W < 2 > { MODE_8BIT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "recorder_control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [recorder_control](index.html) module"]
pub struct RECORDER_CONTROL_SPEC ; impl crate :: RegisterSpec for RECORDER_CONTROL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [recorder_control::R](R) reader structure"]
impl crate :: Readable for RECORDER_CONTROL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [recorder_control::W](W) writer structure"]
impl crate :: Writable for RECORDER_CONTROL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } } # [doc = "recorder_next_address (r) register accessor: an alias for `Reg<RECORDER_NEXT_ADDRESS_SPEC>`"]
pub type RECORDER_NEXT_ADDRESS = crate :: Reg < recorder_next_address :: RECORDER_NEXT_ADDRESS_SPEC > ; # [doc = "recorder_next_address"]
pub mod recorder_next_address { # [doc = "Register `recorder_next_address` reader"]
pub struct R (crate :: R < RECORDER_NEXT_ADDRESS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RECORDER_NEXT_ADDRESS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RECORDER_NEXT_ADDRESS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RECORDER_NEXT_ADDRESS_SPEC >) -> Self { R (reader) } } # [doc = "Field `next_address` reader - next_address"]
pub type NEXT_ADDRESS_R = crate :: FieldReader < u32 > ; impl R { # [doc = "Bits 0:31 - next_address"]
# [inline (always)]
pub fn next_address (& self) -> NEXT_ADDRESS_R { NEXT_ADDRESS_R :: new (self . bits) } } # [doc = "recorder_next_address\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [recorder_next_address](index.html) module"]
pub struct RECORDER_NEXT_ADDRESS_SPEC ; impl crate :: RegisterSpec for RECORDER_NEXT_ADDRESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [recorder_next_address::R](R) reader structure"]
impl crate :: Readable for RECORDER_NEXT_ADDRESS_SPEC { type Reader = R ; } } # [doc = "spectrometer (rw) register accessor: an alias for `Reg<SPECTROMETER_SPEC>`"]
pub type SPECTROMETER = crate :: Reg < spectrometer :: SPECTROMETER_SPEC > ; # [doc = "spectrometer"]
pub mod spectrometer { # [doc = "Register `spectrometer` reader"]
pub struct R (crate :: R < SPECTROMETER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPECTROMETER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPECTROMETER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPECTROMETER_SPEC >) -> Self { R (reader) } } # [doc = "Register `spectrometer` writer"]
pub struct W (crate :: W < SPECTROMETER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPECTROMETER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPECTROMETER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPECTROMETER_SPEC >) -> Self { W (writer) } } # [doc = "Field `num_integrations` reader - num_integrations"]
pub type NUM_INTEGRATIONS_R = crate :: FieldReader < u16 > ; # [doc = "Field `num_integrations` writer - num_integrations"]
pub type NUM_INTEGRATIONS_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , SPECTROMETER_SPEC , 10 , O , u16 > ; # [doc = "Field `last_buffer` reader - last_buffer"]
pub type LAST_BUFFER_R = crate :: FieldReader ; # [doc = "Field `peak_detect` reader - peak_detect"]
pub type PEAK_DETECT_R = crate :: BitReader ; # [doc = "Field `peak_detect` writer - peak_detect"]
pub type PEAK_DETECT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , SPECTROMETER_SPEC , O > ; impl R { # [doc = "Bits 0:9 - num_integrations"]
# [inline (always)]
pub fn num_integrations (& self) -> NUM_INTEGRATIONS_R { NUM_INTEGRATIONS_R :: new ((self . bits & 0x03ff) as u16) } # [doc = "Bits 10:12 - last_buffer"]
# [inline (always)]
pub fn last_buffer (& self) -> LAST_BUFFER_R { LAST_BUFFER_R :: new (((self . bits >> 10) & 7) as u8) } # [doc = "Bit 13 - peak_detect"]
# [inline (always)]
pub fn peak_detect (& self) -> PEAK_DETECT_R { PEAK_DETECT_R :: new (((self . bits >> 13) & 1) != 0) } } impl W { # [doc = "Bits 0:9 - num_integrations"]
# [inline (always)]
# [must_use]
pub fn num_integrations (& mut self) -> NUM_INTEGRATIONS_W < 0 > { NUM_INTEGRATIONS_W :: new (self) } # [doc = "Bit 13 - peak_detect"]
# [inline (always)]
# [must_use]
pub fn peak_detect (& mut self) -> PEAK_DETECT_W < 13 > { PEAK_DETECT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "spectrometer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [spectrometer](index.html) module"]
pub struct SPECTROMETER_SPEC ; impl crate :: RegisterSpec for SPECTROMETER_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [spectrometer::R](R) reader structure"]
impl crate :: Readable for SPECTROMETER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [spectrometer::W](W) writer structure"]
impl crate :: Writable for SPECTROMETER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } } } # [no_mangle]
static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."]
# [allow (non_snake_case)]
pub struct Peripherals { # [doc = "MAIA_SDR"]
pub MAIA_SDR : MAIA_SDR , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."]
# [cfg (feature = "critical-section")]
# [inline]
pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Each of the returned peripherals must be used at most once."]
# [inline]
pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { MAIA_SDR : MAIA_SDR { _marker : PhantomData } , } } }