#![doc = "Peripheral access API for MAIA SDR microcontrollers (generated using svd2rust v0.33.4 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.4/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic {
    use core::marker;
    #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
    pub trait RawReg:
        Copy
        + Default
        + From<bool>
        + core::ops::BitOr<Output = Self>
        + core::ops::BitAnd<Output = Self>
        + core::ops::BitOrAssign
        + core::ops::BitAndAssign
        + core::ops::Not<Output = Self>
        + core::ops::Shl<u8, Output = Self>
    {
        #[doc = " Mask for bits of width `WI`"]
        fn mask<const WI: u8>() -> Self;
        #[doc = " Mask for bits of width 1"]
        fn one() -> Self;
    }
    macro_rules! raw_reg {
        ($ U : ty , $ size : literal , $ mask : ident) => {
            impl RawReg for $U {
                #[inline(always)]
                fn mask<const WI: u8>() -> Self {
                    $mask::<WI>()
                }
                #[inline(always)]
                fn one() -> Self {
                    1
                }
            }
            const fn $mask<const WI: u8>() -> $U {
                <$U>::MAX >> ($size - WI)
            }
            impl FieldSpec for $U {
                type Ux = $U;
            }
        };
    }
    raw_reg!(u8, 8, mask_u8);
    raw_reg!(u16, 16, mask_u16);
    raw_reg!(u32, 32, mask_u32);
    raw_reg!(u64, 64, mask_u64);
    #[doc = " Raw register type"]
    pub trait RegisterSpec {
        #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
        type Ux: RawReg;
    }
    #[doc = " Raw field type"]
    pub trait FieldSpec: Sized {
        #[doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
        type Ux: Copy + core::fmt::Debug + PartialEq + From<Self>;
    }
    #[doc = " Marker for fields with fixed values"]
    pub trait IsEnum: FieldSpec {}
    #[doc = " Trait implemented by readable registers to enable the `read` method."]
    #[doc = ""]
    #[doc = " Registers marked with `Writable` can be also be `modify`'ed."]
    pub trait Readable: RegisterSpec {}
    #[doc = " Trait implemented by writeable registers."]
    #[doc = ""]
    #[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
    #[doc = ""]
    #[doc = " Registers marked with `Readable` can be also be `modify`'ed."]
    pub trait Writable: RegisterSpec {
        #[doc = " Is it safe to write any bits to register"]
        type Safety;
        #[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
        const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
        #[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
        const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
    }
    #[doc = " Reset value of the register."]
    #[doc = ""]
    #[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
    #[doc = " register by using the `reset` method."]
    pub trait Resettable: RegisterSpec {
        #[doc = " Reset value of the register."]
        const RESET_VALUE: Self::Ux;
        #[doc = " Reset value of the register."]
        #[inline(always)]
        fn reset_value() -> Self::Ux {
            Self::RESET_VALUE
        }
    }
    #[doc(hidden)]
    pub mod raw {
        use super::{marker, BitM, FieldSpec, RegisterSpec, Unsafe, Writable};
        pub struct R<REG: RegisterSpec> {
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct W<REG: RegisterSpec> {
            #[doc = "Writable bits"]
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct FieldReader<FI = u8>
        where
            FI: FieldSpec,
        {
            pub(crate) bits: FI::Ux,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI: FieldSpec> FieldReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: FI::Ux) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        pub struct BitReader<FI = bool> {
            pub(crate) bits: bool,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI> BitReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: bool) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        pub struct FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, Safety)>,
        }
        impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
        pub struct BitWriter<'a, REG, FI = bool, M = BitM>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, M)>,
        }
        impl<'a, REG, FI, M> BitWriter<'a, REG, FI, M>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
    }
    #[doc = " Register reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
    #[doc = " method."]
    pub type R<REG> = raw::R<REG>;
    impl<REG: RegisterSpec> R<REG> {
        #[doc = " Reads raw bits from register."]
        #[inline(always)]
        pub const fn bits(&self) -> REG::Ux {
            self.bits
        }
    }
    impl<REG: RegisterSpec, FI> PartialEq<FI> for R<REG>
    where
        REG::Ux: PartialEq,
        FI: Copy,
        REG::Ux: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&REG::Ux::from(*other))
        }
    }
    #[doc = " Register writer."]
    #[doc = ""]
    #[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
    pub type W<REG> = raw::W<REG>;
    impl<REG: Writable> W<REG> {
        #[doc = " Writes raw bits to the register."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    impl<REG> W<REG>
    where
        REG: Writable<Safety = Safe>,
    {
        #[doc = " Writes raw bits to the register."]
        #[inline(always)]
        pub fn set(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    #[doc = " Field reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of fields."]
    pub type FieldReader<FI = u8> = raw::FieldReader<FI>;
    #[doc = " Bit-wise field reader"]
    pub type BitReader<FI = bool> = raw::BitReader<FI>;
    impl<FI: FieldSpec> FieldReader<FI> {
        #[doc = " Reads raw bits from field."]
        #[inline(always)]
        pub const fn bits(&self) -> FI::Ux {
            self.bits
        }
    }
    impl<FI: FieldSpec> core::fmt::Debug for FieldReader<FI> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.bits, f)
        }
    }
    impl<FI> PartialEq<FI> for FieldReader<FI>
    where
        FI: FieldSpec + Copy,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&FI::Ux::from(*other))
        }
    }
    impl<FI> PartialEq<FI> for BitReader<FI>
    where
        FI: Copy,
        bool: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&bool::from(*other))
        }
    }
    impl<FI> BitReader<FI> {
        #[doc = " Value of the field as raw bits."]
        #[inline(always)]
        pub const fn bit(&self) -> bool {
            self.bits
        }
        #[doc = " Returns `true` if the bit is clear (0)."]
        #[inline(always)]
        pub const fn bit_is_clear(&self) -> bool {
            !self.bit()
        }
        #[doc = " Returns `true` if the bit is set (1)."]
        #[inline(always)]
        pub const fn bit_is_set(&self) -> bool {
            self.bit()
        }
    }
    impl<FI> core::fmt::Debug for BitReader<FI> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.bits, f)
        }
    }
    #[doc = " Marker for register/field writers which can take any value of specified width"]
    pub struct Safe;
    #[doc = " You should check that value is allowed to pass to register/field writer marked with this"]
    pub struct Unsafe;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct Range<const MIN: u64, const MAX: u64>;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct RangeFrom<const MIN: u64>;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct RangeTo<const MAX: u64>;
    #[doc = " Write field Proxy"]
    pub type FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe> =
        raw::FieldWriter<'a, REG, WI, FI, Safety>;
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
        #[doc = " Field width"]
        #[inline(always)]
        pub const fn width(&self) -> u8 {
            WI
        }
        #[doc = " Field offset"]
        #[inline(always)]
        pub const fn offset(&self) -> u8 {
            self.o
        }
    }
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(self, value: FI::Ux) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::mask::<WI>() << self.o);
            self.w.bits |= (REG::Ux::from(value) & REG::Ux::mask::<WI>()) << self.o;
            self.w
        }
    }
    impl<'a, REG, const WI: u8, FI> FieldWriter<'a, REG, WI, FI, Safe>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MIN: u64, const MAX: u64>
        FieldWriter<'a, REG, WI, FI, Range<MIN, MAX>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value >= MIN && value <= MAX);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MIN: u64> FieldWriter<'a, REG, WI, FI, RangeFrom<MIN>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value >= MIN);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MAX: u64> FieldWriter<'a, REG, WI, FI, RangeTo<MAX>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value <= MAX);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: IsEnum,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut W<REG> {
            unsafe { self.bits(FI::Ux::from(variant)) }
        }
    }
    macro_rules! bit_proxy {
        ($ writer : ident , $ mwv : ident) => {
            #[doc(hidden)]
            pub struct $mwv;
            #[doc = " Bit-wise write field proxy"]
            pub type $writer<'a, REG, FI = bool> = raw::BitWriter<'a, REG, FI, $mwv>;
            impl<'a, REG, FI> $writer<'a, REG, FI>
            where
                REG: Writable + RegisterSpec,
                bool: From<FI>,
            {
                #[doc = " Field width"]
                pub const WIDTH: u8 = 1;
                #[doc = " Field width"]
                #[inline(always)]
                pub const fn width(&self) -> u8 {
                    Self::WIDTH
                }
                #[doc = " Field offset"]
                #[inline(always)]
                pub const fn offset(&self) -> u8 {
                    self.o
                }
                #[doc = " Writes bit to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W<REG> {
                    self.w.bits &= !(REG::Ux::one() << self.o);
                    self.w.bits |= (REG::Ux::from(value) & REG::Ux::one()) << self.o;
                    self.w
                }
                #[doc = " Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: FI) -> &'a mut W<REG> {
                    self.bit(bool::from(variant))
                }
            }
        };
    }
    bit_proxy!(BitWriter, BitM);
    bit_proxy!(BitWriter1S, Bit1S);
    bit_proxy!(BitWriter0C, Bit0C);
    bit_proxy!(BitWriter1C, Bit1C);
    bit_proxy!(BitWriter0S, Bit0S);
    bit_proxy!(BitWriter1T, Bit1T);
    bit_proxy!(BitWriter0T, Bit0T);
    impl<'a, REG, FI> BitWriter<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Clears the field bit by passing one"]
        #[inline(always)]
        pub fn clear_bit_by_one(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Sets the field bit by passing zero"]
        #[inline(always)]
        pub fn set_bit_by_zero(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing one"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing zero"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
    #[doc = " This structure provides volatile access to registers."]
    #[repr(transparent)]
    pub struct Reg<REG: RegisterSpec> {
        register: vcell::VolatileCell<REG::Ux>,
        _marker: marker::PhantomData<REG>,
    }
    unsafe impl<REG: RegisterSpec> Send for Reg<REG> where REG::Ux: Send {}
    impl<REG: RegisterSpec> Reg<REG> {
        #[doc = " Returns the underlying memory address of register."]
        #[doc = ""]
        #[doc = " ```ignore"]
        #[doc = " let reg_ptr = periph.reg.as_ptr();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn as_ptr(&self) -> *mut REG::Ux {
            self.register.as_ptr()
        }
    }
    impl<REG: Readable> Reg<REG> {
        #[doc = " Reads the contents of a `Readable` register."]
        #[doc = ""]
        #[doc = " You can read the raw contents of a register by using `bits`:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.read().bits();"]
        #[doc = " ```"]
        #[doc = " or get the content of a particular field of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let reader = periph.reg.read();"]
        #[doc = " let bits = reader.field1().bits();"]
        #[doc = " let flag = reader.field2().bit_is_set();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn read(&self) -> R<REG> {
            R {
                bits: self.register.get(),
                _reg: marker::PhantomData,
            }
        }
    }
    impl<REG: Resettable + Writable> Reg<REG> {
        #[doc = " Writes the reset value to `Writable` register."]
        #[doc = ""]
        #[doc = " Resets the register to its initial state."]
        #[inline(always)]
        pub fn reset(&self) {
            self.register.set(REG::RESET_VALUE)
        }
        #[doc = " Writes bits to a `Writable` register."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[inline(always)]
        pub fn write<F>(&self, f: F)
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut W {
                    bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                        | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                    _reg: marker::PhantomData,
                })
                .bits,
            );
        }
    }
    impl<REG: Writable> Reg<REG> {
        #[doc = " Writes 0 to a `Writable` register."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn write_with_zero<F>(&self, f: F)
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut W {
                    bits: REG::Ux::default(),
                    _reg: marker::PhantomData,
                })
                .bits,
            );
        }
    }
    impl<REG: Readable + Writable> Reg<REG> {
        #[doc = " Modifies the contents of the register by reading and then writing it."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
        #[doc = "    r.bits() | 3"]
        #[doc = " ) });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn modify<F>(&self, f: F)
        where
            for<'w> F: FnOnce(&R<REG>, &'w mut W<REG>) -> &'w mut W<REG>,
        {
            let bits = self.register.get();
            self.register.set(
                f(
                    &R {
                        bits,
                        _reg: marker::PhantomData,
                    },
                    &mut W {
                        bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                            | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                        _reg: marker::PhantomData,
                    },
                )
                .bits,
            );
        }
    }
    impl<REG: Readable> core::fmt::Debug for crate::generic::Reg<REG>
    where
        R<REG>: core::fmt::Debug,
    {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.read(), f)
        }
    }
}
#[doc = "Maia SDR IP core"]
pub struct MaiaSdr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MaiaSdr {}
impl MaiaSdr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const maia_sdr::RegisterBlock = 0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const maia_sdr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MaiaSdr {
    type Target = maia_sdr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MaiaSdr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MaiaSdr").finish()
    }
}
#[doc = "Maia SDR IP core"]
pub mod maia_sdr {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        product_id: ProductId,
        version: Version,
        control: Control,
        interrupts: Interrupts,
        recorder_control: RecorderControl,
        recorder_next_address: RecorderNextAddress,
        _reserved6: [u8; 0x08],
        spectrometer: Spectrometer,
        ddc_coeff_addr: DdcCoeffAddr,
        ddc_coeff: DdcCoeff,
        ddc_decimation: DdcDecimation,
        ddc_frequency: DdcFrequency,
        ddc_control: DdcControl,
    }
    impl RegisterBlock {
        #[doc = "0x00 - product_id"]
        #[inline(always)]
        pub const fn product_id(&self) -> &ProductId {
            &self.product_id
        }
        #[doc = "0x04 - version"]
        #[inline(always)]
        pub const fn version(&self) -> &Version {
            &self.version
        }
        #[doc = "0x08 - control"]
        #[inline(always)]
        pub const fn control(&self) -> &Control {
            &self.control
        }
        #[doc = "0x0c - interrupts"]
        #[inline(always)]
        pub const fn interrupts(&self) -> &Interrupts {
            &self.interrupts
        }
        #[doc = "0x10 - recorder_control"]
        #[inline(always)]
        pub const fn recorder_control(&self) -> &RecorderControl {
            &self.recorder_control
        }
        #[doc = "0x14 - recorder_next_address"]
        #[inline(always)]
        pub const fn recorder_next_address(&self) -> &RecorderNextAddress {
            &self.recorder_next_address
        }
        #[doc = "0x20 - spectrometer"]
        #[inline(always)]
        pub const fn spectrometer(&self) -> &Spectrometer {
            &self.spectrometer
        }
        #[doc = "0x24 - ddc_coeff_addr"]
        #[inline(always)]
        pub const fn ddc_coeff_addr(&self) -> &DdcCoeffAddr {
            &self.ddc_coeff_addr
        }
        #[doc = "0x28 - ddc_coeff"]
        #[inline(always)]
        pub const fn ddc_coeff(&self) -> &DdcCoeff {
            &self.ddc_coeff
        }
        #[doc = "0x2c - ddc_decimation"]
        #[inline(always)]
        pub const fn ddc_decimation(&self) -> &DdcDecimation {
            &self.ddc_decimation
        }
        #[doc = "0x30 - ddc_frequency"]
        #[inline(always)]
        pub const fn ddc_frequency(&self) -> &DdcFrequency {
            &self.ddc_frequency
        }
        #[doc = "0x34 - ddc_control"]
        #[inline(always)]
        pub const fn ddc_control(&self) -> &DdcControl {
            &self.ddc_control
        }
    }
    #[doc = "product_id (r) register accessor: product_id\n\nYou can [`read`](crate::Reg::read) this register and get [`product_id::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@product_id`]
module"]
    #[doc(alias = "product_id")]
    pub type ProductId = crate::Reg<product_id::ProductIdSpec>;
    #[doc = "product_id"]
    pub mod product_id {
        #[doc = "Register `product_id` reader"]
        pub type R = crate::R<ProductIdSpec>;
        #[doc = "Field `product_id` reader - product_id"]
        pub type ProductIdR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - product_id"]
            #[inline(always)]
            pub fn product_id(&self) -> ProductIdR {
                ProductIdR::new(self.bits)
            }
        }
        #[doc = "product_id\n\nYou can [`read`](crate::Reg::read) this register and get [`product_id::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ProductIdSpec;
        impl crate::RegisterSpec for ProductIdSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`product_id::R`](R) reader structure"]
        impl crate::Readable for ProductIdSpec {}
    }
    #[doc = "version (r) register accessor: version\n\nYou can [`read`](crate::Reg::read) this register and get [`version::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@version`]
module"]
    #[doc(alias = "version")]
    pub type Version = crate::Reg<version::VersionSpec>;
    #[doc = "version"]
    pub mod version {
        #[doc = "Register `version` reader"]
        pub type R = crate::R<VersionSpec>;
        #[doc = "Field `bugfix` reader - bugfix"]
        pub type BugfixR = crate::FieldReader;
        #[doc = "Field `minor` reader - minor"]
        pub type MinorR = crate::FieldReader;
        #[doc = "Field `major` reader - major"]
        pub type MajorR = crate::FieldReader;
        #[doc = "Field `platform` reader - platform"]
        pub type PlatformR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - bugfix"]
            #[inline(always)]
            pub fn bugfix(&self) -> BugfixR {
                BugfixR::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - minor"]
            #[inline(always)]
            pub fn minor(&self) -> MinorR {
                MinorR::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - major"]
            #[inline(always)]
            pub fn major(&self) -> MajorR {
                MajorR::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31 - platform"]
            #[inline(always)]
            pub fn platform(&self) -> PlatformR {
                PlatformR::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        #[doc = "version\n\nYou can [`read`](crate::Reg::read) this register and get [`version::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct VersionSpec;
        impl crate::RegisterSpec for VersionSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`version::R`](R) reader structure"]
        impl crate::Readable for VersionSpec {}
    }
    #[doc = "control (rw) register accessor: control\n\nYou can [`read`](crate::Reg::read) this register and get [`control::R`]. You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control`]
module"]
    #[doc(alias = "control")]
    pub type Control = crate::Reg<control::ControlSpec>;
    #[doc = "control"]
    pub mod control {
        #[doc = "Register `control` reader"]
        pub type R = crate::R<ControlSpec>;
        #[doc = "Register `control` writer"]
        pub type W = crate::W<ControlSpec>;
        #[doc = "Field `sdr_reset` reader - sdr_reset"]
        pub type SdrResetR = crate::BitReader;
        #[doc = "Field `sdr_reset` writer - sdr_reset"]
        pub type SdrResetW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - sdr_reset"]
            #[inline(always)]
            pub fn sdr_reset(&self) -> SdrResetR {
                SdrResetR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - sdr_reset"]
            #[inline(always)]
            #[must_use]
            pub fn sdr_reset(&mut self) -> SdrResetW<ControlSpec> {
                SdrResetW::new(self, 0)
            }
        }
        #[doc = "control\n\nYou can [`read`](crate::Reg::read) this register and get [`control::R`](R). You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ControlSpec;
        impl crate::RegisterSpec for ControlSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`control::R`](R) reader structure"]
        impl crate::Readable for ControlSpec {}
        #[doc = "`write(|w| ..)` method takes [`control::W`](W) writer structure"]
        impl crate::Writable for ControlSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
    }
    #[doc = "interrupts (r) register accessor: interrupts\n\nYou can [`read`](crate::Reg::read) this register and get [`interrupts::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@interrupts`]
module"]
    #[doc(alias = "interrupts")]
    pub type Interrupts = crate::Reg<interrupts::InterruptsSpec>;
    #[doc = "interrupts"]
    pub mod interrupts {
        #[doc = "Register `interrupts` reader"]
        pub type R = crate::R<InterruptsSpec>;
        #[doc = "Field `spectrometer` reader - spectrometer"]
        pub type SpectrometerR = crate::BitReader;
        #[doc = "Field `recorder` reader - recorder"]
        pub type RecorderR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - spectrometer"]
            #[inline(always)]
            pub fn spectrometer(&self) -> SpectrometerR {
                SpectrometerR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - recorder"]
            #[inline(always)]
            pub fn recorder(&self) -> RecorderR {
                RecorderR::new(((self.bits >> 1) & 1) != 0)
            }
        }
        #[doc = "interrupts\n\nYou can [`read`](crate::Reg::read) this register and get [`interrupts::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct InterruptsSpec;
        impl crate::RegisterSpec for InterruptsSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`interrupts::R`](R) reader structure"]
        impl crate::Readable for InterruptsSpec {}
    }
    #[doc = "recorder_control (rw) register accessor: recorder_control\n\nYou can [`read`](crate::Reg::read) this register and get [`recorder_control::R`]. You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`recorder_control::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@recorder_control`]
module"]
    #[doc(alias = "recorder_control")]
    pub type RecorderControl = crate::Reg<recorder_control::RecorderControlSpec>;
    #[doc = "recorder_control"]
    pub mod recorder_control {
        #[doc = "Register `recorder_control` reader"]
        pub type R = crate::R<RecorderControlSpec>;
        #[doc = "Register `recorder_control` writer"]
        pub type W = crate::W<RecorderControlSpec>;
        #[doc = "Field `start` writer - start"]
        pub type StartW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `stop` writer - stop"]
        pub type StopW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `mode` reader - mode"]
        pub type ModeR = crate::FieldReader;
        #[doc = "Field `mode` writer - mode"]
        pub type ModeW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `dropped_samples` reader - dropped_samples"]
        pub type DroppedSamplesR = crate::BitReader;
        impl R {
            #[doc = "Bits 2:3 - mode"]
            #[inline(always)]
            pub fn mode(&self) -> ModeR {
                ModeR::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bit 4 - dropped_samples"]
            #[inline(always)]
            pub fn dropped_samples(&self) -> DroppedSamplesR {
                DroppedSamplesR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - start"]
            #[inline(always)]
            #[must_use]
            pub fn start(&mut self) -> StartW<RecorderControlSpec> {
                StartW::new(self, 0)
            }
            #[doc = "Bit 1 - stop"]
            #[inline(always)]
            #[must_use]
            pub fn stop(&mut self) -> StopW<RecorderControlSpec> {
                StopW::new(self, 1)
            }
            #[doc = "Bits 2:3 - mode"]
            #[inline(always)]
            #[must_use]
            pub fn mode(&mut self) -> ModeW<RecorderControlSpec> {
                ModeW::new(self, 2)
            }
        }
        #[doc = "recorder_control\n\nYou can [`read`](crate::Reg::read) this register and get [`recorder_control::R`](R). You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`recorder_control::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RecorderControlSpec;
        impl crate::RegisterSpec for RecorderControlSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`recorder_control::R`](R) reader structure"]
        impl crate::Readable for RecorderControlSpec {}
        #[doc = "`write(|w| ..)` method takes [`recorder_control::W`](W) writer structure"]
        impl crate::Writable for RecorderControlSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
    }
    #[doc = "recorder_next_address (r) register accessor: recorder_next_address\n\nYou can [`read`](crate::Reg::read) this register and get [`recorder_next_address::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@recorder_next_address`]
module"]
    #[doc(alias = "recorder_next_address")]
    pub type RecorderNextAddress = crate::Reg<recorder_next_address::RecorderNextAddressSpec>;
    #[doc = "recorder_next_address"]
    pub mod recorder_next_address {
        #[doc = "Register `recorder_next_address` reader"]
        pub type R = crate::R<RecorderNextAddressSpec>;
        #[doc = "Field `next_address` reader - next_address"]
        pub type NextAddressR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - next_address"]
            #[inline(always)]
            pub fn next_address(&self) -> NextAddressR {
                NextAddressR::new(self.bits)
            }
        }
        #[doc = "recorder_next_address\n\nYou can [`read`](crate::Reg::read) this register and get [`recorder_next_address::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RecorderNextAddressSpec;
        impl crate::RegisterSpec for RecorderNextAddressSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`recorder_next_address::R`](R) reader structure"]
        impl crate::Readable for RecorderNextAddressSpec {}
    }
    #[doc = "spectrometer (rw) register accessor: spectrometer\n\nYou can [`read`](crate::Reg::read) this register and get [`spectrometer::R`]. You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`spectrometer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@spectrometer`]
module"]
    #[doc(alias = "spectrometer")]
    pub type Spectrometer = crate::Reg<spectrometer::SpectrometerSpec>;
    #[doc = "spectrometer"]
    pub mod spectrometer {
        #[doc = "Register `spectrometer` reader"]
        pub type R = crate::R<SpectrometerSpec>;
        #[doc = "Register `spectrometer` writer"]
        pub type W = crate::W<SpectrometerSpec>;
        #[doc = "Field `use_ddc_out` reader - use_ddc_out"]
        pub type UseDdcOutR = crate::BitReader;
        #[doc = "Field `use_ddc_out` writer - use_ddc_out"]
        pub type UseDdcOutW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `num_integrations` reader - num_integrations"]
        pub type NumIntegrationsR = crate::FieldReader<u16>;
        #[doc = "Field `num_integrations` writer - num_integrations"]
        pub type NumIntegrationsW<'a, REG> = crate::FieldWriter<'a, REG, 10, u16>;
        #[doc = "Field `abort` writer - abort"]
        pub type AbortW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `last_buffer` reader - last_buffer"]
        pub type LastBufferR = crate::FieldReader;
        #[doc = "Field `peak_detect` reader - peak_detect"]
        pub type PeakDetectR = crate::BitReader;
        #[doc = "Field `peak_detect` writer - peak_detect"]
        pub type PeakDetectW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - use_ddc_out"]
            #[inline(always)]
            pub fn use_ddc_out(&self) -> UseDdcOutR {
                UseDdcOutR::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 1:10 - num_integrations"]
            #[inline(always)]
            pub fn num_integrations(&self) -> NumIntegrationsR {
                NumIntegrationsR::new(((self.bits >> 1) & 0x03ff) as u16)
            }
            #[doc = "Bits 12:14 - last_buffer"]
            #[inline(always)]
            pub fn last_buffer(&self) -> LastBufferR {
                LastBufferR::new(((self.bits >> 12) & 7) as u8)
            }
            #[doc = "Bit 15 - peak_detect"]
            #[inline(always)]
            pub fn peak_detect(&self) -> PeakDetectR {
                PeakDetectR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - use_ddc_out"]
            #[inline(always)]
            #[must_use]
            pub fn use_ddc_out(&mut self) -> UseDdcOutW<SpectrometerSpec> {
                UseDdcOutW::new(self, 0)
            }
            #[doc = "Bits 1:10 - num_integrations"]
            #[inline(always)]
            #[must_use]
            pub fn num_integrations(&mut self) -> NumIntegrationsW<SpectrometerSpec> {
                NumIntegrationsW::new(self, 1)
            }
            #[doc = "Bit 11 - abort"]
            #[inline(always)]
            #[must_use]
            pub fn abort(&mut self) -> AbortW<SpectrometerSpec> {
                AbortW::new(self, 11)
            }
            #[doc = "Bit 15 - peak_detect"]
            #[inline(always)]
            #[must_use]
            pub fn peak_detect(&mut self) -> PeakDetectW<SpectrometerSpec> {
                PeakDetectW::new(self, 15)
            }
        }
        #[doc = "spectrometer\n\nYou can [`read`](crate::Reg::read) this register and get [`spectrometer::R`](R). You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`spectrometer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SpectrometerSpec;
        impl crate::RegisterSpec for SpectrometerSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`spectrometer::R`](R) reader structure"]
        impl crate::Readable for SpectrometerSpec {}
        #[doc = "`write(|w| ..)` method takes [`spectrometer::W`](W) writer structure"]
        impl crate::Writable for SpectrometerSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
    }
    #[doc = "ddc_coeff_addr (rw) register accessor: ddc_coeff_addr\n\nYou can [`read`](crate::Reg::read) this register and get [`ddc_coeff_addr::R`]. You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ddc_coeff_addr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ddc_coeff_addr`]
module"]
    #[doc(alias = "ddc_coeff_addr")]
    pub type DdcCoeffAddr = crate::Reg<ddc_coeff_addr::DdcCoeffAddrSpec>;
    #[doc = "ddc_coeff_addr"]
    pub mod ddc_coeff_addr {
        #[doc = "Register `ddc_coeff_addr` reader"]
        pub type R = crate::R<DdcCoeffAddrSpec>;
        #[doc = "Register `ddc_coeff_addr` writer"]
        pub type W = crate::W<DdcCoeffAddrSpec>;
        #[doc = "Field `coeff_waddr` reader - coeff_waddr"]
        pub type CoeffWaddrR = crate::FieldReader<u16>;
        #[doc = "Field `coeff_waddr` writer - coeff_waddr"]
        pub type CoeffWaddrW<'a, REG> = crate::FieldWriter<'a, REG, 10, u16>;
        impl R {
            #[doc = "Bits 0:9 - coeff_waddr"]
            #[inline(always)]
            pub fn coeff_waddr(&self) -> CoeffWaddrR {
                CoeffWaddrR::new((self.bits & 0x03ff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:9 - coeff_waddr"]
            #[inline(always)]
            #[must_use]
            pub fn coeff_waddr(&mut self) -> CoeffWaddrW<DdcCoeffAddrSpec> {
                CoeffWaddrW::new(self, 0)
            }
        }
        #[doc = "ddc_coeff_addr\n\nYou can [`read`](crate::Reg::read) this register and get [`ddc_coeff_addr::R`](R). You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ddc_coeff_addr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DdcCoeffAddrSpec;
        impl crate::RegisterSpec for DdcCoeffAddrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ddc_coeff_addr::R`](R) reader structure"]
        impl crate::Readable for DdcCoeffAddrSpec {}
        #[doc = "`write(|w| ..)` method takes [`ddc_coeff_addr::W`](W) writer structure"]
        impl crate::Writable for DdcCoeffAddrSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
    }
    #[doc = "ddc_coeff (rw) register accessor: ddc_coeff\n\nYou can [`read`](crate::Reg::read) this register and get [`ddc_coeff::R`]. You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ddc_coeff::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ddc_coeff`]
module"]
    #[doc(alias = "ddc_coeff")]
    pub type DdcCoeff = crate::Reg<ddc_coeff::DdcCoeffSpec>;
    #[doc = "ddc_coeff"]
    pub mod ddc_coeff {
        #[doc = "Register `ddc_coeff` reader"]
        pub type R = crate::R<DdcCoeffSpec>;
        #[doc = "Register `ddc_coeff` writer"]
        pub type W = crate::W<DdcCoeffSpec>;
        #[doc = "Field `coeff_wren` writer - coeff_wren"]
        pub type CoeffWrenW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `coeff_wdata` reader - coeff_wdata"]
        pub type CoeffWdataR = crate::FieldReader<u32>;
        #[doc = "Field `coeff_wdata` writer - coeff_wdata"]
        pub type CoeffWdataW<'a, REG> = crate::FieldWriter<'a, REG, 18, u32>;
        impl R {
            #[doc = "Bits 1:18 - coeff_wdata"]
            #[inline(always)]
            pub fn coeff_wdata(&self) -> CoeffWdataR {
                CoeffWdataR::new((self.bits >> 1) & 0x0003_ffff)
            }
        }
        impl W {
            #[doc = "Bit 0 - coeff_wren"]
            #[inline(always)]
            #[must_use]
            pub fn coeff_wren(&mut self) -> CoeffWrenW<DdcCoeffSpec> {
                CoeffWrenW::new(self, 0)
            }
            #[doc = "Bits 1:18 - coeff_wdata"]
            #[inline(always)]
            #[must_use]
            pub fn coeff_wdata(&mut self) -> CoeffWdataW<DdcCoeffSpec> {
                CoeffWdataW::new(self, 1)
            }
        }
        #[doc = "ddc_coeff\n\nYou can [`read`](crate::Reg::read) this register and get [`ddc_coeff::R`](R). You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ddc_coeff::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DdcCoeffSpec;
        impl crate::RegisterSpec for DdcCoeffSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ddc_coeff::R`](R) reader structure"]
        impl crate::Readable for DdcCoeffSpec {}
        #[doc = "`write(|w| ..)` method takes [`ddc_coeff::W`](W) writer structure"]
        impl crate::Writable for DdcCoeffSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
    }
    #[doc = "ddc_decimation (rw) register accessor: ddc_decimation\n\nYou can [`read`](crate::Reg::read) this register and get [`ddc_decimation::R`]. You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ddc_decimation::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ddc_decimation`]
module"]
    #[doc(alias = "ddc_decimation")]
    pub type DdcDecimation = crate::Reg<ddc_decimation::DdcDecimationSpec>;
    #[doc = "ddc_decimation"]
    pub mod ddc_decimation {
        #[doc = "Register `ddc_decimation` reader"]
        pub type R = crate::R<DdcDecimationSpec>;
        #[doc = "Register `ddc_decimation` writer"]
        pub type W = crate::W<DdcDecimationSpec>;
        #[doc = "Field `decimation1` reader - decimation1"]
        pub type Decimation1R = crate::FieldReader;
        #[doc = "Field `decimation1` writer - decimation1"]
        pub type Decimation1W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        #[doc = "Field `decimation2` reader - decimation2"]
        pub type Decimation2R = crate::FieldReader;
        #[doc = "Field `decimation2` writer - decimation2"]
        pub type Decimation2W<'a, REG> = crate::FieldWriter<'a, REG, 6>;
        #[doc = "Field `decimation3` reader - decimation3"]
        pub type Decimation3R = crate::FieldReader;
        #[doc = "Field `decimation3` writer - decimation3"]
        pub type Decimation3W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        impl R {
            #[doc = "Bits 0:6 - decimation1"]
            #[inline(always)]
            pub fn decimation1(&self) -> Decimation1R {
                Decimation1R::new((self.bits & 0x7f) as u8)
            }
            #[doc = "Bits 7:12 - decimation2"]
            #[inline(always)]
            pub fn decimation2(&self) -> Decimation2R {
                Decimation2R::new(((self.bits >> 7) & 0x3f) as u8)
            }
            #[doc = "Bits 13:19 - decimation3"]
            #[inline(always)]
            pub fn decimation3(&self) -> Decimation3R {
                Decimation3R::new(((self.bits >> 13) & 0x7f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:6 - decimation1"]
            #[inline(always)]
            #[must_use]
            pub fn decimation1(&mut self) -> Decimation1W<DdcDecimationSpec> {
                Decimation1W::new(self, 0)
            }
            #[doc = "Bits 7:12 - decimation2"]
            #[inline(always)]
            #[must_use]
            pub fn decimation2(&mut self) -> Decimation2W<DdcDecimationSpec> {
                Decimation2W::new(self, 7)
            }
            #[doc = "Bits 13:19 - decimation3"]
            #[inline(always)]
            #[must_use]
            pub fn decimation3(&mut self) -> Decimation3W<DdcDecimationSpec> {
                Decimation3W::new(self, 13)
            }
        }
        #[doc = "ddc_decimation\n\nYou can [`read`](crate::Reg::read) this register and get [`ddc_decimation::R`](R). You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ddc_decimation::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DdcDecimationSpec;
        impl crate::RegisterSpec for DdcDecimationSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ddc_decimation::R`](R) reader structure"]
        impl crate::Readable for DdcDecimationSpec {}
        #[doc = "`write(|w| ..)` method takes [`ddc_decimation::W`](W) writer structure"]
        impl crate::Writable for DdcDecimationSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
    }
    #[doc = "ddc_frequency (rw) register accessor: ddc_frequency\n\nYou can [`read`](crate::Reg::read) this register and get [`ddc_frequency::R`]. You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ddc_frequency::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ddc_frequency`]
module"]
    #[doc(alias = "ddc_frequency")]
    pub type DdcFrequency = crate::Reg<ddc_frequency::DdcFrequencySpec>;
    #[doc = "ddc_frequency"]
    pub mod ddc_frequency {
        #[doc = "Register `ddc_frequency` reader"]
        pub type R = crate::R<DdcFrequencySpec>;
        #[doc = "Register `ddc_frequency` writer"]
        pub type W = crate::W<DdcFrequencySpec>;
        #[doc = "Field `frequency` reader - frequency"]
        pub type FrequencyR = crate::FieldReader<u32>;
        #[doc = "Field `frequency` writer - frequency"]
        pub type FrequencyW<'a, REG> = crate::FieldWriter<'a, REG, 28, u32>;
        impl R {
            #[doc = "Bits 0:27 - frequency"]
            #[inline(always)]
            pub fn frequency(&self) -> FrequencyR {
                FrequencyR::new(self.bits & 0x0fff_ffff)
            }
        }
        impl W {
            #[doc = "Bits 0:27 - frequency"]
            #[inline(always)]
            #[must_use]
            pub fn frequency(&mut self) -> FrequencyW<DdcFrequencySpec> {
                FrequencyW::new(self, 0)
            }
        }
        #[doc = "ddc_frequency\n\nYou can [`read`](crate::Reg::read) this register and get [`ddc_frequency::R`](R). You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ddc_frequency::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DdcFrequencySpec;
        impl crate::RegisterSpec for DdcFrequencySpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ddc_frequency::R`](R) reader structure"]
        impl crate::Readable for DdcFrequencySpec {}
        #[doc = "`write(|w| ..)` method takes [`ddc_frequency::W`](W) writer structure"]
        impl crate::Writable for DdcFrequencySpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
    }
    #[doc = "ddc_control (rw) register accessor: ddc_control\n\nYou can [`read`](crate::Reg::read) this register and get [`ddc_control::R`]. You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ddc_control::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ddc_control`]
module"]
    #[doc(alias = "ddc_control")]
    pub type DdcControl = crate::Reg<ddc_control::DdcControlSpec>;
    #[doc = "ddc_control"]
    pub mod ddc_control {
        #[doc = "Register `ddc_control` reader"]
        pub type R = crate::R<DdcControlSpec>;
        #[doc = "Register `ddc_control` writer"]
        pub type W = crate::W<DdcControlSpec>;
        #[doc = "Field `operations_minus_one1` reader - operations_minus_one1"]
        pub type OperationsMinusOne1R = crate::FieldReader;
        #[doc = "Field `operations_minus_one1` writer - operations_minus_one1"]
        pub type OperationsMinusOne1W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        #[doc = "Field `operations_minus_one2` reader - operations_minus_one2"]
        pub type OperationsMinusOne2R = crate::FieldReader;
        #[doc = "Field `operations_minus_one2` writer - operations_minus_one2"]
        pub type OperationsMinusOne2W<'a, REG> = crate::FieldWriter<'a, REG, 6>;
        #[doc = "Field `operations_minus_one3` reader - operations_minus_one3"]
        pub type OperationsMinusOne3R = crate::FieldReader;
        #[doc = "Field `operations_minus_one3` writer - operations_minus_one3"]
        pub type OperationsMinusOne3W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        #[doc = "Field `odd_operations1` reader - odd_operations1"]
        pub type OddOperations1R = crate::BitReader;
        #[doc = "Field `odd_operations1` writer - odd_operations1"]
        pub type OddOperations1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `odd_operations3` reader - odd_operations3"]
        pub type OddOperations3R = crate::BitReader;
        #[doc = "Field `odd_operations3` writer - odd_operations3"]
        pub type OddOperations3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `bypass2` reader - bypass2"]
        pub type Bypass2R = crate::BitReader;
        #[doc = "Field `bypass2` writer - bypass2"]
        pub type Bypass2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `bypass3` reader - bypass3"]
        pub type Bypass3R = crate::BitReader;
        #[doc = "Field `bypass3` writer - bypass3"]
        pub type Bypass3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `enable_input` reader - enable_input"]
        pub type EnableInputR = crate::BitReader;
        #[doc = "Field `enable_input` writer - enable_input"]
        pub type EnableInputW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:6 - operations_minus_one1"]
            #[inline(always)]
            pub fn operations_minus_one1(&self) -> OperationsMinusOne1R {
                OperationsMinusOne1R::new((self.bits & 0x7f) as u8)
            }
            #[doc = "Bits 7:12 - operations_minus_one2"]
            #[inline(always)]
            pub fn operations_minus_one2(&self) -> OperationsMinusOne2R {
                OperationsMinusOne2R::new(((self.bits >> 7) & 0x3f) as u8)
            }
            #[doc = "Bits 13:19 - operations_minus_one3"]
            #[inline(always)]
            pub fn operations_minus_one3(&self) -> OperationsMinusOne3R {
                OperationsMinusOne3R::new(((self.bits >> 13) & 0x7f) as u8)
            }
            #[doc = "Bit 20 - odd_operations1"]
            #[inline(always)]
            pub fn odd_operations1(&self) -> OddOperations1R {
                OddOperations1R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - odd_operations3"]
            #[inline(always)]
            pub fn odd_operations3(&self) -> OddOperations3R {
                OddOperations3R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - bypass2"]
            #[inline(always)]
            pub fn bypass2(&self) -> Bypass2R {
                Bypass2R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - bypass3"]
            #[inline(always)]
            pub fn bypass3(&self) -> Bypass3R {
                Bypass3R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - enable_input"]
            #[inline(always)]
            pub fn enable_input(&self) -> EnableInputR {
                EnableInputR::new(((self.bits >> 24) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:6 - operations_minus_one1"]
            #[inline(always)]
            #[must_use]
            pub fn operations_minus_one1(&mut self) -> OperationsMinusOne1W<DdcControlSpec> {
                OperationsMinusOne1W::new(self, 0)
            }
            #[doc = "Bits 7:12 - operations_minus_one2"]
            #[inline(always)]
            #[must_use]
            pub fn operations_minus_one2(&mut self) -> OperationsMinusOne2W<DdcControlSpec> {
                OperationsMinusOne2W::new(self, 7)
            }
            #[doc = "Bits 13:19 - operations_minus_one3"]
            #[inline(always)]
            #[must_use]
            pub fn operations_minus_one3(&mut self) -> OperationsMinusOne3W<DdcControlSpec> {
                OperationsMinusOne3W::new(self, 13)
            }
            #[doc = "Bit 20 - odd_operations1"]
            #[inline(always)]
            #[must_use]
            pub fn odd_operations1(&mut self) -> OddOperations1W<DdcControlSpec> {
                OddOperations1W::new(self, 20)
            }
            #[doc = "Bit 21 - odd_operations3"]
            #[inline(always)]
            #[must_use]
            pub fn odd_operations3(&mut self) -> OddOperations3W<DdcControlSpec> {
                OddOperations3W::new(self, 21)
            }
            #[doc = "Bit 22 - bypass2"]
            #[inline(always)]
            #[must_use]
            pub fn bypass2(&mut self) -> Bypass2W<DdcControlSpec> {
                Bypass2W::new(self, 22)
            }
            #[doc = "Bit 23 - bypass3"]
            #[inline(always)]
            #[must_use]
            pub fn bypass3(&mut self) -> Bypass3W<DdcControlSpec> {
                Bypass3W::new(self, 23)
            }
            #[doc = "Bit 24 - enable_input"]
            #[inline(always)]
            #[must_use]
            pub fn enable_input(&mut self) -> EnableInputW<DdcControlSpec> {
                EnableInputW::new(self, 24)
            }
        }
        #[doc = "ddc_control\n\nYou can [`read`](crate::Reg::read) this register and get [`ddc_control::R`](R). You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ddc_control::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DdcControlSpec;
        impl crate::RegisterSpec for DdcControlSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ddc_control::R`](R) reader structure"]
        impl crate::Readable for DdcControlSpec {}
        #[doc = "`write(|w| ..)` method takes [`ddc_control::W`](W) writer structure"]
        impl crate::Writable for DdcControlSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "Maia SDR"]
    pub maia_sdr: MaiaSdr,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            maia_sdr: MaiaSdr::steal(),
        }
    }
}
